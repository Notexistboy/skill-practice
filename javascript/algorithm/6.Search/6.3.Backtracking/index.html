<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题：
    1、路径：也就是已经做出的选择。
    2、选择列表：也就是你当前可以做的选择。
    3、结束条件：也就是到达决策树底层，无法再做选择的条件。

    如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。
    代码方面，回溯算法的框架：
    result = []
    def backtrack(路径, 选择列表):
    if 满足结束条件:
    result.add(路径)
    return

    for 选择 in 选择列表:
    # 做选择
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, 选择列表)
    # 撤销选择
    路径.remove(选择)
    将该选择再加入选择列表

    其核心就是 for 循环里面的递归，在递归调用之前「做选择」，
    在递归调用之后「撤销选择」，特别简单。

    选择和撤销

    一、全排列问题
    排列组合的数学题，我们也知道n个不重复的数，全排列共有 n! 个。
    PS：为了简单清晰起见，我们这次讨论的全排列问题不包含重复的数字。
    那么我们当时是怎么穷举全排列的呢？比方说给三个数[1,2,3]，你肯定不会无规律地乱穷举，一般是这样：
    先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；
    然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……
    其实这就是回溯算法，我们高中无师自通就会用，或者有的同学直接画出如下这棵回溯树：
    只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。我们不妨把这棵树称为回溯算法的「决策树」。
    为啥说这是决策树呢，因为你在每个节点上其实都在做决策。

    <script>

    </script>
</body>

</html>