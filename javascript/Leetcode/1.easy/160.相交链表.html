<!DOCTYPE html>
  <html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>
  <body>
    <div>

    </div>
    <script type="text/javascript">
        /*
            要求时间复杂度为O(N)，空间复杂度为O(1)。如果不存在交点则返回null。
            设A的长度为a+c，B的长度为b+c，其中c为尾部公共部分长度，可知a+c+b=b+c+a。
            当访问A链表的指针访问到链表尾部时，令它从链表B的头部开始访问链表B；同样地，当访问B链表的指针访问到链表尾部时，令它从链表A的头部开始访问链表A。这样就能控制访问A和B两个链表的指针能同时访问到交点。
            如果不存在交点，那么a+b=b+a，以下实现代码中l1和l2会同时为null，从而退出循环。
        */
        /* 
            如果只是判断是否存在交点，那么就是另一个问题，即 编程之美 3.6 的问题。有两种解法：
            把第一个链表的结尾连接到第二个链表的开头，看第二个链表是否存在环；
            或者直接比较两个链表的最后一个节点是否相同。
         */
        /**
        * Definition for singly-linked list.
        * function ListNode(val) {
        *     this.val = val;
        *     this.next = null;
        * }
        */

        /**
        * @param {ListNode} headA
        * @param {ListNode} headB
        * @return {ListNode}
        */
        var getIntersectionNode = function(headA, headB) {
            if(!headA || !headB) return null;
            let l1 = headA, l2 = headB;
            while (l1 != l2) {
                l1 = (l1 == null) ? headB : l1.next;
                l2 = (l2 == null) ? headA : l2.next;
            }
            return l1;
        };
    </script>
  </body>
</html>