<!DOCTYPE html>
  <html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>
  <body>
    <div>

    </div>
    <script type="text/javascript">
      /* 
        给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
        设计一个算法来计算你所能获取的最大利润。
        你可以尽可能地完成更多的交易（多次买卖一支股票）。
        注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
       */
      /* 
        从第 i 天（这里 i >= 1）开始，与第 i - 1 的股价进行比较，
        如果股价有上升（严格上升），就将升高的股价（ prices[i] - prices[i- 1] ）记入总利润，
        按照这种算法，得到的结果就是符合题意的最大利润。
       */
      /* 
        1、该算法仅可以用于计算，但计算的过程并不是真正交易的过程，
        但可以用贪心算法计算题目要求的最大利润。
        下面说明这个等价性：以 [1, 2, 3, 4] 为例，
        这 4 天的股价依次上升，按照贪心算法，得到的最大利润是：
        res =  (prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])
        =  prices[3] - prices[0]
       */
      /* 
        仔细观察上面的式子，按照贪心算法，在索引为 1、2、3 的这三天，
        我们做的操作应该是买进昨天的，卖出今天的，虽然这种操作题目并不允许，
        但是它等价于：“在索引为 0 的那一天买入，在索引为 3 的那一天卖出”。
       */
      /* 
        贪心算法” 在每一步总是做出在当前看来最好的选择。
        
        因此，
        “贪心算法” 和 “动态规划”、“回溯搜索” 算法一样，完成一件事情，是分步决策的；
        “贪心算法” 在每一步总是做出在当前看来最好的选择，我是这样理解 “最好” 这两个字的意思：
        “最好” 的意思往往根据题目而来，可能是 “最小”，也可能是 “最大”；
        贪心算法和动态规划相比，它既不看前面（也就是说它不需要从前面的状态转移过来），
        也不看后面（无后效性，后面的选择不会对前面的选择有影响），
        因此贪心算法时间复杂度一般是线性的，空间复杂度是常数级别的。
       */
        /**
        * @param {number[]} prices
        * @return {number}
        */
        var maxProfit = function(prices) {
          let res = 0
          let len = prices.length
          for(let i = 0; i< len-1; i++){
            /* 用后面的数 不断的减前面的数 */
            debugger
            let diff = prices[i+1] - prices[i]
            if(diff > 0){
              res += diff
            }
            debugger
          }
          return res
        };
        console.log(maxProfit([7,1,5,3,6,4]))
    </script>
  </body>
</html>