<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <div>

  </div>
  <script type="text/javascript">
    /* 
        给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。
        函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。
        说明:
        返回的下标值（index1 和 index2）不是从零开始的。
        你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
      */
    /**
     * @param {number[]} numbers
     * @param {number} target
     * @return {number[]}
     */
    /* 第一种解法利用二分查找 */
    /* 第二种解法是通过双指针实现 */
    /* 
    初始时两个指针分别指向第一个元素位置和最后一个元素的位置。
    每次计算两个指针指向的两个元素之和，并和目标值比较。
    如果两个元素之和等于目标值，则发现了唯一解。
    如果两个元素之和小于目标值，则将左侧指针右移一位。
    如果两个元素之和大于目标值，则将右侧指针左移一位。
    移动指针之后，重复上述操作，直到找到答案。

    使用双指针的实质是缩小查找范围。那么会不会把可能的解过滤掉？
    答案是不会。假设 {numbers}[i]+{numbers}[j]={target}numbers[i]+numbers[j]=target 
    是唯一解，其中 0  i<j  {numbers.length}-10≤i<j≤numbers.length−1。
    初始时两个指针分别指向下标 0 和下标 {numbers.length}-1numbers.length−1，
    左指针指向的下标小于或等于 i，右指针指向的下标大于或等于 j。
    除非初始时左指针和右指针已经位于下标 i 和 j，
    否则一定是左指针先到达下标 i 的位置或者右指针先到达下标 j 的位置。

    如果左指针先到达下标 i 的位置，此时右指针还在下标 j 的右侧，
    {sum}>{target}sum>target，因此一定是右指针左移，
    左指针不可能移到 i 的右侧。

    如果右指针先到达下标 j 的位置，此时左指针还在下标 i 的左侧，
    {sum}<{target}sum<target，因此一定是左指针右移，
    右指针不可能移到 j 的左侧。

    由此可见，在整个移动过程中，左指针不可能移到 i 的右侧，
    右指针不可能移到 j 的左侧，因此不会把可能的解过滤掉。
    由于题目确保有唯一的答案，因此使用双指针一定可以找到答案。
    
    只需要使用常数个数据变量 空间复杂度是O(1)
    只需要使用一次数据遍历 时间复杂度是O(n)
     */
    var twoSum = function (numbers, target) {
      let len = numbers.length
      let left = 0 //左侧指针
      let right = len - 1 //右侧指针
      while (left <= right) {
        let res = numbers[left] + numbers[right]
        if (res < target) {
          left += 1
        } else if (res > target) {
          right -= 1
        } else {
          return [left + 1, right + 1]
        }
      }
      return [-1, -1]
    };
    twoSum([2, 7, 11, 15], 9)
    /* 
    其他双指针:
    11.盛最多水的容器
    15.三数之和
    26.删除排序数组中的重复项
     */
  </script>
</body>

</html>