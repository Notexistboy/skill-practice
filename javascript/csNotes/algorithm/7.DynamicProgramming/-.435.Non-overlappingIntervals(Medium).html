<!DOCTYPE html>
  <html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>
  <body>
    <div>

    </div>
    <script type="text/javascript">
    /* 
    
    给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

    注意:
    可以认为区间的终点总是大于它的起点。
    区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。
    示例 1:
    输入: [ [1,2], [2,3], [3,4], [1,3] ]
    输出: 1
    解释: 移除 [1,3] 后，剩下的区间没有重叠。
     */
    /* 
    方法1：从起始点的动态规划
    方法2：从终点的动态规划
    方法3：从起点的贪心算法
    */
    /* 
      从起始点的动态规划
      算法

      如果我们按照起始点对区间进行排序，可以很大程度上简化问题。
      一旦完成之后，我们就可以使用一个 dp 数组，其中 dp[i]
      存储着只考虑到 第i个第i个 区间范围内（包括其本身），
      最大可能的区间数。现在，当计算 dp[i+1] 时，
      我们不能只考虑 dp[i] 的值，因为前面的 i 个区间都可能与 第i+1 个区间发生重叠。
      因此，我们需要考虑能够使得j≤i 且与第 i+1 个区间不发生重叠的所有 dp[j] 中的最大值。
      状态转移方程如下：

      dp[i+1]= \max(dp[j]) + 1,
      dp[i+1]=max(dp[j])+1,

      其中对于所有 j≤i ，第 i 个和第 j 个区间不发生重叠。

      最后，为了计算最终列表中区间的最大区间数量，我们需要找到 dp 数组中的最大值。
      最终的结果为区间的总数减去刚刚的结果 (intervals.length-ansintervals.length−ans)。


    */
    var eraseOverlapIntervals = function(intervals) {
      if(intervals.length == 0) return 0
      intervals.sort((a,b) => a[0] - b[0])
    };
    /* 
      从终点的动态规划 【通过】
      
      算法
      在上面讨论过的 DP 算法中，为了计算每个 dp[i] 的值，
      我们需要遍历 dp 数组，直到起始索引。
      如果我们使用根据终点排序的列表，
      则可以去除这一开销。我们依然使用 dp 数组，
      其中 dp[i] 用于存储存储着只考虑到 第i个第i个 区间范围内（包括其本身），
      最大可能的区间数。为了计算 dp[i+1] ，考虑两种情况:

      情况一
      第 i+1 个区间对应的区间需要被包括在最终列表中以达到删除区间最少:
      在这种情况下，我们需要从第 i+1 到开头遍历区间数组，寻找第一个不重叠的区间。
      这是由于，如果我们要包含当前区间，我们就需要移除所有和当前区间重叠的区间。
      但我们不需要每次都回到开头，相反，我们可以在找到第一个不重叠的区间后停止遍历，
      并用 dp[j]+1 填入 dp[i+1] ，因为 dp[j] 是存储直到第 j 个区间范围内最大区间数的元素。

      情况二
      第 i+1 个区间对应的区间需要被移除以达到删除区间最少：
      在这种情况下，当前元素不会被包括在最终列表中。
      因此，考虑到第 i+1 个区间的最大数量和 只考虑到 i 个的相同。
      因此，我们用 dp[i] 的值填充 dp[i+1]。
      最终 dp[i+1] 的值为上述两值中较大的。
    
    
     */
    var eraseOverlapIntervals = function(intervals) {
      if(intervals.length == 0) return 0
      intervals.sort((a,b) => a[1] - b[1])
    };
    </script>
  </body>
</html>